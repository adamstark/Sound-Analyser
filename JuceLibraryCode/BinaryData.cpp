/* ==================================== JUCER_BINARY_RESOURCE ====================================

   This is an auto-generated file: Any edits you make may be overwritten!

*/

namespace BinaryData
{

//================== CHANGELOG ==================
static const unsigned char temp_binary_data_0[] =
"1.3.0 2012-07-18\n"
"  removed non-standard malloc.h from kiss_fft.h\n"
"\n"
"  moved -lm to end of link line\n"
"\n"
"  checked various return values\n"
"\n"
"  converted python Numeric code to NumPy\n"
" \n"
"  fixed test of int32_t on 64 bit OS\n"
"\n"
"  added padding in a couple of places to allow SIMD alignment of structs\n"
"\n"
"1.2.9 2010-05-27\n"
"  threadsafe ( including OpenMP )\n"
"\n"
"  first edition of kissfft.hh the C++ template fft engine\n"
" \n"
"1.2.8 \n"
"  Changed memory.h to string.h -- apparently more standard\n"
"  \n"
"  Added openmp extensions.  This can have fairly linear speedups for larger FFT sizes.\n"
"\n"
"1.2.7 \n"
"  Shrank the real-fft memory footprint. Thanks to Galen Seitz.\n"
"\n"
"1.2.6 (Nov 14, 2006) The \"thanks to GenArts\" release.\n"
"  Added multi-dimensional real-optimized FFT, see tools/kiss_fftndr\n"
"  Thanks go to GenArts, Inc. for sponsoring the development.\n"
"\n"
"1.2.5 (June 27, 2006) The \"release for no good reason\" release.\n"
"   Changed some harmless code to make some compilers' warnings go away.\n"
"   Added some more digits to pi -- why not.\n"
"   Added kiss_fft_next_fast_size() function to help people decide how much to pad.\n"
"   Changed multidimensional test from 8 dimensions to only 3 to avoid testing \n"
"   problems with fixed point (sorry Buckaroo Banzai).\n"
"\n"
"1.2.4 (Oct 27, 2005)   The \"oops, inverse fixed point real fft was borked\" release. \n"
"   Fixed scaling bug for inverse fixed point real fft -- also fixed test code that should've been failing.\n"
"    Thanks to Jean-Marc Valin for bug report.\n"
"\n"
"   Use sys/types.h for more portable types than short,int,long => int16_t,int32_t,int64_t\n"
"   If your system does not have these, you may need to define them -- but at least it breaks in a \n"
"   loud and easily fixable way -- unlike silently using the wrong size type.\n"
"\n"
"   Hopefully tools/psdpng.c is fixed -- thanks to Steve Kellog for pointing out the weirdness.\n"
"\n"
"1.2.3 (June 25, 2005)   The \"you want to use WHAT as a sample\" release.\n"
"    Added ability to use 32 bit fixed point samples -- requires a 64 bit intermediate result, a la 'long long'\n"
"\n"
"    Added ability to do 4 FFTs in parallel by using SSE SIMD instructions. This is accomplished by\n"
"    using the __m128 (vector of 4 floats) as kiss_fft_scalar.  Define USE_SIMD to use this.\n"
"    \n"
"    I know, I know ...  this is drifting a bit from the \"kiss\" principle, but the speed advantages \n"
"    make it worth it for some.  Also recent gcc makes it SOO easy to use vectors of 4 floats like a POD type.\n"
"\n"
"1.2.2 (May 6, 2005)   The Matthew release\n"
"    Replaced fixed point division with multiply&shift.  Thanks to Jean-Marc Valin for \n"
"    discussions regarding.  Considerable speedup for fixed-point.\n"
"\n"
"    Corrected overflow protection in real fft routines  when using fixed point.\n"
"    Finder's Credit goes to Robert Oschler of robodance for pointing me at the bug.\n"
"    This also led to the CHECK_OVERFLOW_OP macro.\n"
"\n"
"1.2.1 (April 4, 2004) \n"
"    compiles cleanly with just about every -W warning flag under the sun\n"
"\n"
"    reorganized kiss_fft_state so it could be read-only/const. This may be useful for embedded systems\n"
"    that are willing to predeclare twiddle factors, factorization.\n"
"\n"
"    Fixed C_MUL,S_MUL on 16-bit platforms.\n"
"\n"
"    tmpbuf will only be allocated if input & output buffers are same\n"
"    scratchbuf will only be allocated for ffts that are not multiples of 2,3,5\n"
" \n"
"    NOTE: The tmpbuf,scratchbuf changes may require synchronization code for multi-threaded apps.\n"
"\n"
"\n"
"1.2 (Feb 23, 2004)\n"
"    interface change -- cfg object is forward declaration of struct instead of void*\n"
"    This maintains type saftey and lets the compiler warn/error about stupid mistakes.\n"
"            (prompted by suggestion from Erik de Castro Lopo)\n"
"\n"
"    small speed improvements\n"
"\n"
"    added psdpng.c -- sample utility that will create png spectrum \"waterfalls\" from an input file\n"
"        ( not terribly useful yet)\n"
"\n"
"1.1.1 (Feb 1, 2004 )\n"
"    minor bug fix -- only affects odd rank, in-place, multi-dimensional FFTs\n"
"\n"
"1.1 : (Jan 30,2004)\n"
"    split sample_code/ into test/ and tools/\n"
"\n"
"    Removed 2-D fft and added N-D fft (arbitrary)\n"
"\n"
"    modified fftutil.c to allow multi-d FFTs\n"
"\n"
"    Modified core fft routine to allow an input stride via kiss_fft_stride()\n"
"    (eased support of multi-D ffts)\n"
"\n"
"    Added fast convolution filtering (FIR filtering using overlap-scrap method, with tail scrap)\n"
"\n"
"    Add kfc.[ch]: the KISS FFT Cache. It takes care of allocs for you ( suggested by Oscar Lesta ).\n"
"\n"
"1.0.1 (Dec 15, 2003)\n"
"    fixed bug that occurred when nfft==1. Thanks to Steven Johnson.\n"
"    \n"
"1.0 : (Dec 14, 2003)\n"
"    changed kiss_fft function from using a single buffer, to two buffers.\n"
"    If the same buffer pointer is supplied for both in and out, kiss will\n"
"    manage the buffer copies.\n"
"\n"
"    added kiss_fft2d and kiss_fftr as separate source files (declarations in kiss_fft.h )\n"
"\n"
"0.4 :(Nov 4,2003) optimized for radix 2,3,4,5\n"
"\n"
"0.3 :(Oct 28, 2003) woops, version 2 didn't actually factor out any radices other than 2.\n"
"        Thanks to Steven Johnson for finding this one.\n"
"\n"
"0.2 :(Oct 27, 2003) added mixed radix, only radix 2,4 optimized versions\n"
"\n"
"0.1 :(May 19 2003)  initial release, radix 2 only\n";

const char* CHANGELOG = (const char*) temp_binary_data_0;

//================== COPYING ==================
static const unsigned char temp_binary_data_1[] =
"Copyright (c) 2003-2010 Mark Borgerding\n"
"\n"
"All rights reserved.\n"
"\n"
"Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n"
"\n"
"    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n"
"    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n"
"    * Neither the author nor the names of any contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n"
"\n"
"THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO E"
"VENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR"
" BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH D"
"AMAGE.\n";

const char* COPYING = (const char*) temp_binary_data_1;

//================== Makefile ==================
static const unsigned char temp_binary_data_2[] =
"KFVER=130\n"
"\n"
"doc:\n"
"\t@echo \"Start by reading the README file.  If you want to build and test lots of stuff, do a 'make testall'\"\n"
"\t@echo \"but be aware that 'make testall' has dependencies that the basic kissfft software does not.\"\n"
"\t@echo \"It is generally unneeded to run these tests yourself, unless you plan on changing the inner workings\"\n"
"\t@echo \"of kissfft and would like to make use of its regression tests.\"\n"
"\n"
"testall:\n"
"\t# The simd and int32_t types may or may not work on your machine \n"
"\tmake -C test DATATYPE=simd CFLAGADD=\"$(CFLAGADD)\" test\n"
"\tmake -C test DATATYPE=int32_t CFLAGADD=\"$(CFLAGADD)\" test\n"
"\tmake -C test DATATYPE=int16_t CFLAGADD=\"$(CFLAGADD)\" test\n"
"\tmake -C test DATATYPE=float CFLAGADD=\"$(CFLAGADD)\" test\n"
"\tmake -C test DATATYPE=double CFLAGADD=\"$(CFLAGADD)\" test\n"
"\techo \"all tests passed\"\n"
"\n"
"tarball: clean\n"
"\thg archive -r v$(KFVER) -t tgz kiss_fft$(KFVER).tar.gz \n"
"\thg archive -r v$(KFVER) -t zip kiss_fft$(KFVER).zip\n"
"\n"
"clean:\n"
"\tcd test && make clean\n"
"\tcd tools && make clean\n"
"\trm -f kiss_fft*.tar.gz *~ *.pyc kiss_fft*.zip \n"
"\n"
"asm: kiss_fft.s\n"
"\n"
"kiss_fft.s: kiss_fft.c kiss_fft.h _kiss_fft_guts.h\n"
"\t[ -e kiss_fft.s ] && mv kiss_fft.s kiss_fft.s~ || true\n"
"\tgcc -S kiss_fft.c -O3 -mtune=native -ffast-math -fomit-frame-pointer -unroll-loops -dA -fverbose-asm \n"
"\tgcc -o kiss_fft_short.s -S kiss_fft.c -O3 -mtune=native -ffast-math -fomit-frame-pointer -dA -fverbose-asm -DFIXED_POINT\n"
"\t[ -e kiss_fft.s~ ] && diff kiss_fft.s~ kiss_fft.s || true\n";

const char* Makefile = (const char*) temp_binary_data_2;

//================== README ==================
static const unsigned char temp_binary_data_3[] =
"KISS FFT - A mixed-radix Fast Fourier Transform based up on the principle, \n"
"\"Keep It Simple, Stupid.\"\n"
"\n"
"    There are many great fft libraries already around.  Kiss FFT is not trying\n"
"to be better than any of them.  It only attempts to be a reasonably efficient, \n"
"moderately useful FFT that can use fixed or floating data types and can be \n"
"incorporated into someone's C program in a few minutes with trivial licensing.\n"
"\n"
"USAGE:\n"
"\n"
"    The basic usage for 1-d complex FFT is:\n"
"\n"
"        #include \"kiss_fft.h\"\n"
"\n"
"        kiss_fft_cfg cfg = kiss_fft_alloc( nfft ,is_inverse_fft ,0,0 );\n"
"\n"
"        while ...\n"
"        \n"
"            ... // put kth sample in cx_in[k].r and cx_in[k].i\n"
"            \n"
"            kiss_fft( cfg , cx_in , cx_out );\n"
"            \n"
"            ... // transformed. DC is in cx_out[0].r and cx_out[0].i \n"
"            \n"
"        free(cfg);\n"
"\n"
"    Note: frequency-domain data is stored from dc up to 2pi.\n"
"    so cx_out[0] is the dc bin of the FFT\n"
"    and cx_out[nfft/2] is the Nyquist bin (if exists)\n"
"\n"
"    Declarations are in \"kiss_fft.h\", along with a brief description of the \n"
"functions you'll need to use. \n"
"\n"
"Code definitions for 1d complex FFTs are in kiss_fft.c.\n"
"\n"
"You can do other cool stuff with the extras you'll find in tools/\n"
"\n"
"    * multi-dimensional FFTs \n"
"    * real-optimized FFTs  (returns the positive half-spectrum: (nfft/2+1) complex frequency bins)\n"
"    * fast convolution FIR filtering (not available for fixed point)\n"
"    * spectrum image creation\n"
"\n"
"The core fft and most tools/ code can be compiled to use float, double,\n"
" Q15 short or Q31 samples. The default is float.\n"
"\n"
"\n"
"BACKGROUND:\n"
"\n"
"    I started coding this because I couldn't find a fixed point FFT that didn't \n"
"use assembly code.  I started with floating point numbers so I could get the \n"
"theory straight before working on fixed point issues.  In the end, I had a \n"
"little bit of code that could be recompiled easily to do ffts with short, float\n"
"or double (other types should be easy too).  \n"
"\n"
"    Once I got my FFT working, I was curious about the speed compared to\n"
"a well respected and highly optimized fft library.  I don't want to criticize \n"
"this great library, so let's call it FFT_BRANDX.\n"
"During this process, I learned:\n"
"\n"
"    1. FFT_BRANDX has more than 100K lines of code. The core of kiss_fft is about 500 lines (cpx 1-d).\n"
"    2. It took me an embarrassingly long time to get FFT_BRANDX working.\n"
"    3. A simple program using FFT_BRANDX is 522KB. A similar program using kiss_fft is 18KB (without optimizing for size).\n"
"    4. FFT_BRANDX is roughly twice as fast as KISS FFT in default mode.\n"
"\n"
"    It is wonderful that free, highly optimized libraries like FFT_BRANDX exist.\n"
"But such libraries carry a huge burden of complexity necessary to extract every \n"
"last bit of performance.\n"
"\n"
"    Sometimes simpler is better, even if it's not better.\n"
"\n"
"FREQUENTLY ASKED QUESTIONS:\n"
"\tQ: Can I use kissfft in a project with a ___ license?\n"
"\tA: Yes.  See LICENSE below.\n"
"\n"
"\tQ: Why don't I get the output I expect?\n"
"\tA: The two most common causes of this are \n"
"\t\t1) scaling : is there a constant multiplier between what you got and what you want?\n"
"\t\t2) mixed build environment -- all code must be compiled with same preprocessor \n"
"\t\tdefinitions for FIXED_POINT and kiss_fft_scalar\n"
"\n"
"\tQ: Will you write/debug my code for me?\n"
"\tA: Probably not unless you pay me.  I am happy to answer pointed and topical questions, but \n"
"\tI may refer you to a book, a forum, or some other resource.\n"
"\n"
"\n"
"PERFORMANCE:\n"
"    (on Athlon XP 2100+, with gcc 2.96, float data type)\n"
"\n"
"    Kiss performed 10000 1024-pt cpx ffts in .63 s of cpu time.\n"
"    For comparison, it took md5sum twice as long to process the same amount of data.\n"
"\n"
"    Transforming 5 minutes of CD quality audio takes less than a second (nfft=1024). \n"
"\n"
"DO NOT:\n"
"    ... use Kiss if you need the Fastest Fourier Transform in the World\n"
"    ... ask me to add features that will bloat the code\n"
"\n"
"UNDER THE HOOD:\n"
"\n"
"    Kiss FFT uses a time decimation, mixed-radix, out-of-place FFT. If you give it an input buffer  \n"
"    and output buffer that are the same, a temporary buffer will be created to hold the data.\n"
"\n"
"    No static data is used.  The core routines of kiss_fft are thread-safe (but not all of the tools directory).\n"
"\n"
"    No scaling is done for the floating point version (for speed).  \n"
"    Scaling is done both ways for the fixed-point version (for overflow prevention).\n"
"\n"
"    Optimized butterflies are used for factors 2,3,4, and 5. \n"
"\n"
"    The real (i.e. not complex) optimization code only works for even length ffts.  It does two half-length\n"
"    FFTs in parallel (packed into real&imag), and then combines them via twiddling.  The result is \n"
"    nfft/2+1 complex frequency bins from DC to Nyquist.  If you don't know what this means, search the web.\n"
"\n"
"    The fast convolution filtering uses the overlap-scrap method, slightly \n"
"    modified to put the scrap at the tail.\n"
"\n"
"LICENSE:\n"
"    Revised BSD License, see COPYING for verbiage. \n"
"    Basically, \"free to use&change, give credit where due, no guarantees\"\n"
"    Note this license is compatible with GPL at one end of the spectrum and closed, commercial software at \n"
"    the other end.  See http://www.fsf.org/licensing/licenses\n"
"\n"
"    A commercial license is available which removes the requirement for attribution.  Contact me for details.\n"
"\n"
"  \n"
"TODO:\n"
"    *) Add real optimization for odd length FFTs \n"
"    *) Document/revisit the input/output fft scaling\n"
"    *) Make doc describing the overlap (tail) scrap fast convolution filtering in kiss_fastfir.c\n"
"    *) Test all the ./tools/ code with fixed point (kiss_fastfir.c doesn't work, maybe others)\n"
"\n"
"AUTHOR:\n"
"    Mark Borgerding\n"
"    Mark@Borgerding.net\n";

const char* README = (const char*) temp_binary_data_3;

//================== README.simd ==================
static const unsigned char temp_binary_data_4[] =
"If you are reading this, it means you think you may be interested in using the SIMD extensions in kissfft \n"
"to do 4 *separate* FFTs at once.\n"
"\n"
"Beware! Beyond here there be dragons!\n"
"\n"
"This API is not easy to use, is not well documented, and breaks the KISS principle.  \n"
"\n"
"\n"
"Still reading? Okay, you may get rewarded for your patience with a considerable speedup \n"
"(2-3x) on intel x86 machines with SSE if you are willing to jump through some hoops.\n"
"\n"
"The basic idea is to use the packed 4 float __m128 data type as a scalar element.  \n"
"This means that the format is pretty convoluted. It performs 4 FFTs per fft call on signals A,B,C,D.\n"
"\n"
"For complex data, the data is interlaced as follows:\n"
"rA0,rB0,rC0,rD0,      iA0,iB0,iC0,iD0,   rA1,rB1,rC1,rD1, iA1,iB1,iC1,iD1 ...\n"
"where \"rA0\" is the real part of the zeroth sample for signal A\n"
"\n"
"Real-only data is laid out:\n"
"rA0,rB0,rC0,rD0,     rA1,rB1,rC1,rD1,      ... \n"
"\n"
"Compile with gcc flags something like\n"
"-O3 -mpreferred-stack-boundary=4  -DUSE_SIMD=1 -msse \n"
"\n"
"Be aware of SIMD alignment.  This is the most likely cause of segfaults.  \n"
"The code within kissfft uses scratch variables on the stack.  \n"
"With SIMD, these must have addresses on 16 byte boundaries.  \n"
"Search on \"SIMD alignment\" for more info.\n"
"\n"
"\n"
"\n"
"Robin at Divide Concept was kind enough to share his code for formatting to/from the SIMD kissfft.  \n"
"I have not run it -- use it at your own risk.  It appears to do 4xN and Nx4 transpositions \n"
"(out of place).\n"
"\n"
"void SSETools::pack128(float* target, float* source, unsigned long size128)\n"
"{\n"
"   __m128* pDest = (__m128*)target;\n"
"   __m128* pDestEnd = pDest+size128;\n"
"   float* source0=source;\n"
"   float* source1=source0+size128;\n"
"   float* source2=source1+size128;\n"
"   float* source3=source2+size128;\n"
"\n"
"   while(pDest<pDestEnd)\n"
"   {\n"
"       *pDest=_mm_set_ps(*source3,*source2,*source1,*source0);\n"
"       source0++;\n"
"       source1++;\n"
"       source2++;\n"
"       source3++;\n"
"       pDest++;\n"
"   }\n"
"}\n"
"\n"
"void SSETools::unpack128(float* target, float* source, unsigned long size128)\n"
"{\n"
"\n"
"   float* pSrc = source;\n"
"   float* pSrcEnd = pSrc+size128*4;\n"
"   float* target0=target;\n"
"   float* target1=target0+size128;\n"
"   float* target2=target1+size128;\n"
"   float* target3=target2+size128;\n"
"\n"
"   while(pSrc<pSrcEnd)\n"
"   {\n"
"       *target0=pSrc[0];\n"
"       *target1=pSrc[1];\n"
"       *target2=pSrc[2];\n"
"       *target3=pSrc[3];\n"
"       target0++;\n"
"       target1++;\n"
"       target2++;\n"
"       target3++;\n"
"       pSrc+=4;\n"
"   }\n"
"} \n";

const char* README_simd = (const char*) temp_binary_data_4;

//================== compfft.py ==================
static const unsigned char temp_binary_data_5[] =
"#!/usr/bin/env python\n"
"\n"
"# use FFTPACK as a baseline\n"
"import FFT\n"
"from Numeric import *\n"
"import math\n"
"import random\n"
"import sys\n"
"import struct\n"
"import fft\n"
"\n"
"pi=math.pi\n"
"e=math.e\n"
"j=complex(0,1)\n"
"lims=(-32768,32767)\n"
"\n"
"def randbuf(n,cpx=1):\n"
"    res = array( [ random.uniform( lims[0],lims[1] ) for i in range(n) ] )\n"
"    if cpx:\n"
"        res = res + j*randbuf(n,0)\n"
"    return res\n"
"\n"
"def main():\n"
"    from getopt import getopt\n"
"    import popen2\n"
"    opts,args = getopt( sys.argv[1:],'u:n:Rt:' )\n"
"    opts=dict(opts)\n"
"    exitcode=0\n"
"\n"
"    util = opts.get('-u','./kf_float')\n"
"\n"
"    try:\n"
"        dims = [ int(d) for d in opts['-n'].split(',')]\n"
"        cpx = opts.get('-R') is None\n"
"        fmt=opts.get('-t','f')\n"
"    except KeyError:\n"
"        sys.stderr.write(\"\"\"\n"
"        usage: compfft.py \n"
"        -n d1[,d2,d3...]  : FFT dimension(s)\n"
"        -u utilname : see sample_code/fftutil.c, default = ./kf_float\n"
"        -R : real-optimized version\\n\"\"\")\n"
"        sys.exit(1)\n"
"\n"
"    x = fft.make_random( dims )\n"
"\n"
"    cmd = '%s -n %s ' % ( util, ','.join([ str(d) for d in dims]) )\n"
"    if cpx:\n"
"        xout = FFT.fftnd(x)\n"
"        xout = reshape(xout,(size(xout),))\n"
"    else:\n"
"        cmd += '-R '\n"
"        xout = FFT.real_fft(x)\n"
"\n"
"    proc = popen2.Popen3( cmd , bufsize=len(x) )\n"
"\n"
"    proc.tochild.write( dopack( x , fmt ,cpx ) )\n"
"    proc.tochild.close()\n"
"    xoutcomp = dounpack( proc.fromchild.read( ) , fmt ,1 )\n"
"    #xoutcomp = reshape( xoutcomp , dims )\n"
"\n"
"    sig = xout * conjugate(xout)\n"
"    sigpow = sum( sig )\n"
"\n"
"    diff = xout-xoutcomp\n"
"    noisepow = sum( diff * conjugate(diff) )\n"
"\n"
"    snr = 10 * math.log10(abs( sigpow / noisepow ) )\n"
"    if snr<100:\n"
"        print xout\n"
"        print xoutcomp\n"
"        exitcode=1\n"
"    print 'NFFT=%s,SNR = %f dB' % (str(dims),snr)\n"
"    sys.exit(exitcode)\n"
"\n"
"def dopack(x,fmt,cpx):\n"
"    x = reshape( x, ( size(x),) )\n"
"    if cpx:\n"
"        s = ''.join( [ struct.pack('ff',c.real,c.imag) for c in x ] )\n"
"    else:\n"
"        s = ''.join( [ struct.pack('f',c) for c in x ] )\n"
"    return s \n"
"\n"
"def dounpack(x,fmt,cpx):\n"
"    uf = fmt * ( len(x) / 4 )\n"
"    s = struct.unpack(uf,x)\n"
"    if cpx:\n"
"        return array(s[::2]) + array( s[1::2] )*j\n"
"    else:    \n"
"        return array(s )\n"
"\n"
"if __name__ == \"__main__\":\n"
"    main()\n";

const char* compfft_py = (const char*) temp_binary_data_5;

//================== fastfir.py ==================
static const unsigned char temp_binary_data_6[] =
"#!/usr/bin/env python\n"
"\n"
"from Numeric import *\n"
"from FFT import *\n"
"\n"
"def make_random(len):\n"
"    import random\n"
"    res=[]\n"
"    for i in range(int(len)):\n"
"        r=random.uniform(-1,1)\n"
"        i=random.uniform(-1,1)\n"
"        res.append( complex(r,i) )\n"
"    return res\n"
"\n"
"def slowfilter(sig,h):\n"
"    translen = len(h)-1\n"
"    return convolve(sig,h)[translen:-translen]\n"
"\n"
"def nextpow2(x):\n"
"    return 2 ** math.ceil(math.log(x)/math.log(2))\n"
"\n"
"def fastfilter(sig,h,nfft=None):\n"
"    if nfft is None:\n"
"        nfft = int( nextpow2( 2*len(h) ) )\n"
"    H = fft( h , nfft )\n"
"    scraplen = len(h)-1\n"
"    keeplen = nfft-scraplen\n"
"    res=[]\n"
"    isdone = 0\n"
"    lastidx = nfft\n"
"    idx0 = 0\n"
"    while not isdone:\n"
"        idx1 = idx0 + nfft\n"
"        if idx1 >= len(sig):\n"
"            idx1 = len(sig)\n"
"            lastidx = idx1-idx0\n"
"            if lastidx <= scraplen:\n"
"                break\n"
"            isdone = 1\n"
"        Fss = fft(sig[idx0:idx1],nfft)\n"
"        fm = Fss * H\n"
"        m = inverse_fft(fm)\n"
"        res.append( m[scraplen:lastidx] )\n"
"        idx0 += keeplen\n"
"    return concatenate( res )\n"
"\n"
"def main():\n"
"    import sys\n"
"    from getopt import getopt\n"
"    opts,args = getopt(sys.argv[1:],'rn:l:')\n"
"    opts=dict(opts)\n"
"\n"
"    siglen = int(opts.get('-l',1e4 ) )\n"
"    hlen =50 \n"
" \n"
"    nfft = int(opts.get('-n',128) )\n"
"    usereal = opts.has_key('-r')\n"
"\n"
"    print 'nfft=%d'%nfft\n"
"    # make a signal\n"
"    sig = make_random( siglen )\n"
"    # make an impulse response\n"
"    h = make_random( hlen )\n"
"    #h=[1]*2+[0]*3\n"
"    if usereal:\n"
"        sig=[c.real for c in sig]\n"
"        h=[c.real for c in h]\n"
"\n"
"    # perform MAC filtering\n"
"    yslow = slowfilter(sig,h)\n"
"    #print '<YSLOW>',yslow,'</YSLOW>'\n"
"    #yfast = fastfilter(sig,h,nfft)\n"
"    yfast = utilfastfilter(sig,h,nfft,usereal)\n"
"    #print yfast\n"
"    print 'len(yslow)=%d'%len(yslow)\n"
"    print 'len(yfast)=%d'%len(yfast)\n"
"    diff = yslow-yfast\n"
"    snr = 10*log10( abs( vdot(yslow,yslow) / vdot(diff,diff) ) )\n"
"    print 'snr=%s' % snr\n"
"    if snr < 10.0:\n"
"        print 'h=',h\n"
"        print 'sig=',sig[:5],'...'\n"
"        print 'yslow=',yslow[:5],'...'\n"
"        print 'yfast=',yfast[:5],'...'\n"
"\n"
"def utilfastfilter(sig,h,nfft,usereal):\n"
"    import compfft\n"
"    import os\n"
"    open( 'sig.dat','w').write( compfft.dopack(sig,'f',not usereal) )\n"
"    open( 'h.dat','w').write( compfft.dopack(h,'f',not usereal) )\n"
"    if usereal: \n"
"        util = './fastconvr' \n"
"    else:\n"
"        util = './fastconv'\n"
"    cmd = 'time %s -n %d -i sig.dat -h h.dat -o out.dat' % (util, nfft)\n"
"    print cmd\n"
"    ec  = os.system(cmd)\n"
"    print 'exited->',ec\n"
"    return compfft.dounpack(open('out.dat').read(),'f',not usereal)\n"
"\n"
"if __name__ == \"__main__\":\n"
"    main()\n";

const char* fastfir_py = (const char*) temp_binary_data_6;

//================== fft.py ==================
static const unsigned char temp_binary_data_7[] =
"#!/usr/bin/env python\n"
"\n"
"import math\n"
"import sys\n"
"import random\n"
"\n"
"pi=math.pi\n"
"e=math.e\n"
"j=complex(0,1)\n"
"\n"
"def fft(f,inv):\n"
"    n=len(f)\n"
"    if n==1:\n"
"        return f\n"
"\n"
"    for p in 2,3,5:\n"
"        if n%p==0:\n"
"            break\n"
"    else:\n"
"        raise Exception('%s not factorable ' % n)\n"
"\n"
"    m = n/p\n"
"    Fout=[]\n"
"    for q in range(p): # 0,1\n"
"        fp = f[q::p]  # every p'th time sample\n"
"        Fp = fft( fp ,inv)\n"
"        Fout.extend( Fp )\n"
"\n"
"    for u in range(m):\n"
"        scratch = Fout[u::m] # u to end in strides of m\n"
"        for q1 in range(p):\n"
"            k = q1*m + u  # indices to Fout above that became scratch\n"
"            Fout[ k ] = scratch[0] # cuz e**0==1 in loop below\n"
"            for q in range(1,p):\n"
"                if inv:\n"
"                    t = e ** ( j*2*pi*k*q/n )\n"
"                else:                    \n"
"                    t = e ** ( -j*2*pi*k*q/n )\n"
"                Fout[ k ] += scratch[q] * t\n"
"\n"
"    return Fout\n"
"\n"
"def rifft(F):\n"
"    N = len(F) - 1\n"
"    Z = [0] * (N)\n"
"    for k in range(N):\n"
"        Fek = ( F[k] + F[-k-1].conjugate() )\n"
"        Fok = ( F[k] - F[-k-1].conjugate() ) * e ** (j*pi*k/N)\n"
"        Z[k] = Fek + j*Fok\n"
"\n"
"    fp = fft(Z , 1)\n"
"\n"
"    f = []\n"
"    for c in fp:\n"
"        f.append(c.real)\n"
"        f.append(c.imag)\n"
"    return f\n"
"\n"
"def real_fft( f,inv ):\n"
"    if inv:\n"
"        return rifft(f)\n"
"\n"
"    N = len(f) / 2\n"
"\n"
"    res = f[::2]\n"
"    ims = f[1::2]\n"
"\n"
"    fp = [ complex(r,i) for r,i in zip(res,ims) ]\n"
"    print 'fft input ', fp\n"
"    Fp = fft( fp ,0 )\n"
"    print 'fft output ', Fp\n"
"\n"
"    F = [ complex(0,0) ] * ( N+1 )\n"
"    \n"
"    F[0] = complex( Fp[0].real + Fp[0].imag , 0 ) \n"
"\n"
"    for k in range(1,N/2+1):\n"
"        tw = e ** ( -j*pi*(.5+float(k)/N ) )\n"
"        \n"
"        F1k = Fp[k] + Fp[N-k].conjugate()\n"
"        F2k = Fp[k] - Fp[N-k].conjugate()\n"
"        F2k *= tw\n"
"        F[k] = ( F1k + F2k ) * .5\n"
"        F[N-k] = ( F1k - F2k ).conjugate() * .5\n"
"        #F[N-k] = ( F1kp + e ** ( -j*pi*(.5+float(N-k)/N ) ) * F2kp ) * .5\n"
"        #F[N-k] = ( F1k.conjugate() - tw.conjugate() * F2k.conjugate() ) * .5\n"
"\n"
"    F[N] = complex( Fp[0].real - Fp[0].imag , 0 ) \n"
"    return F\n"
"\n"
"def main():\n"
"    #fft_func = fft\n"
"    fft_func = real_fft\n"
"\n"
"    tvec = [0.309655,0.815653,0.768570,0.591841,0.404767,0.637617,0.007803,0.012665]\n"
"    Ftvec = [ complex(r,i) for r,i in zip(\n"
"                [3.548571,-0.378761,-0.061950,0.188537,-0.566981,0.188537,-0.061950,-0.378761],\n"
"                [0.000000,-1.296198,-0.848764,0.225337,0.000000,-0.225337,0.848764,1.296198] ) ]\n"
"\n"
"    F = fft_func( tvec,0 )\n"
"\n"
"    nerrs= 0\n"
"    for i in range(len(Ftvec)/2 + 1):\n"
"        if abs( F[i] - Ftvec[i] )> 1e-5:\n"
"            print 'F[%d]: %s != %s' % (i,F[i],Ftvec[i])\n"
"            nerrs += 1\n"
"\n"
"    print '%d errors in forward fft' % nerrs\n"
"    if nerrs:\n"
"        return\n"
"\n"
"    trec = fft_func( F , 1 )\n"
"\n"
"    for i in range(len(trec) ):\n"
"        trec[i] /= len(trec)\n"
"\n"
"    for i in range(len(tvec) ):\n"
"        if abs( trec[i] - tvec[i] )> 1e-5:\n"
"            print 't[%d]: %s != %s' % (i,tvec[i],trec[i])\n"
"            nerrs += 1\n"
"\n"
"    print '%d errors in reverse fft' % nerrs\n"
"\n"
"\n"
"def make_random(dims=[1]):\n"
"    import Numeric \n"
"    res = []\n"
"    for i in range(dims[0]):\n"
"        if len(dims)==1:\n"
"            r=random.uniform(-1,1)\n"
"            i=random.uniform(-1,1)\n"
"            res.append( complex(r,i) )\n"
"        else:\n"
"            res.append( make_random( dims[1:] ) )\n"
"    return Numeric.array(res)\n"
"\n"
"def flatten(x):\n"
"    import Numeric\n"
"    ntotal = Numeric.product(Numeric.shape(x))\n"
"    return Numeric.reshape(x,(ntotal,))\n"
"\n"
"def randmat( ndims ):\n"
"    dims=[]\n"
"    for i in range( ndims ):\n"
"        curdim = int( random.uniform(2,4) )\n"
"        dims.append( curdim )\n"
"    return make_random(dims )\n"
"\n"
"def test_fftnd(ndims=3):\n"
"    import FFT\n"
"    import Numeric\n"
"\n"
"    x=randmat( ndims )\n"
"    print 'dimensions=%s' % str( Numeric.shape(x) )\n"
"    #print 'x=%s' %str(x)\n"
"    xver = FFT.fftnd(x)\n"
"    x2=myfftnd(x)\n"
"    err = xver - x2\n"
"    errf = flatten(err)\n"
"    xverf = flatten(xver)\n"
"    errpow = Numeric.vdot(errf,errf)+1e-10\n"
"    sigpow = Numeric.vdot(xverf,xverf)+1e-10\n"
"    snr = 10*math.log10(abs(sigpow/errpow) )\n"
"    if snr<80:\n"
"        print xver\n"
"        print x2\n"
"    print 'SNR=%sdB' % str( snr )\n"
" \n"
"def myfftnd(x):\n"
"    import Numeric\n"
"    xf = flatten(x)\n"
"    Xf = fftndwork( xf , Numeric.shape(x) )\n"
"    return Numeric.reshape(Xf,Numeric.shape(x) )\n"
"\n"
"def fftndwork(x,dims):\n"
"    import Numeric\n"
"    dimprod=Numeric.product( dims )\n"
"\n"
"    for k in range( len(dims) ):\n"
"        cur_dim=dims[ k ]\n"
"        stride=dimprod/cur_dim\n"
"        next_x = [complex(0,0)]*len(x)\n"
"        for i in range(stride):\n"
"            next_x[i*cur_dim:(i+1)*cur_dim] = fft(x[i:(i+cur_dim)*stride:stride],0)\n"
"        x = next_x\n"
"    return x\n"
"\n"
"if __name__ == \"__main__\":\n"
"    try:\n"
"        nd = int(sys.argv[1])\n"
"    except:\n"
"        nd=None\n"
"    if nd:    \n"
"        test_fftnd( nd )\n"
"    else:    \n"
"        sys.exit(0)\n";

const char* fft_py = (const char*) temp_binary_data_7;

//================== Makefile ==================
static const unsigned char temp_binary_data_8[] =
"\n"
"WARNINGS=-W -Wall -Wstrict-prototypes -Wmissing-prototypes -Waggregate-return \\\n"
"    -Wcast-align -Wcast-qual -Wnested-externs -Wshadow -Wbad-function-cast \\\n"
"    -Wwrite-strings\n"
"\n"
"CFLAGS=-O3 -I.. -I../tools $(WARNINGS)\n"
"CFLAGS+=-ffast-math -fomit-frame-pointer \n"
"#CFLAGS+=-funroll-loops\n"
"#CFLAGS+=-march=prescott \n"
"#CFLAGS+= -mtune=native \n"
"# TIP: try adding -openmp or -fopenmp  to enable OPENMP directives and use of multiple cores\n"
"#CFLAGS+=-fopenmp\n"
"CFLAGS+= $(CFLAGADD)\n"
"\n"
"\n"
"ifeq \"$(NFFT)\" \"\"\n"
" NFFT=1800\n"
"endif\n"
"ifeq \"$(NUMFFTS)\" \"\"\n"
" NUMFFTS=10000\n"
"endif\n"
"\n"
"ifeq \"$(DATATYPE)\" \"\"\n"
" DATATYPE=float\n"
"endif\n"
"\n"
"BENCHKISS=bm_kiss_$(DATATYPE)\n"
"BENCHFFTW=bm_fftw_$(DATATYPE)\n"
"SELFTEST=st_$(DATATYPE)\n"
"TESTREAL=tr_$(DATATYPE)\n"
"TESTKFC=tkfc_$(DATATYPE)\n"
"FASTFILTREAL=ffr_$(DATATYPE)\n"
"SELFTESTSRC=twotonetest.c\n"
"\n"
"\n"
"TYPEFLAGS=-Dkiss_fft_scalar=$(DATATYPE)\n"
"\n"
"ifeq  \"$(DATATYPE)\" \"int16_t\" \n"
" TYPEFLAGS=-DFIXED_POINT=16\n"
"endif\n"
"\n"
"ifeq  \"$(DATATYPE)\" \"int32_t\"\n"
" TYPEFLAGS=-DFIXED_POINT=32 \n"
"endif\n"
"\n"
"ifeq  \"$(DATATYPE)\" \"simd\"\n"
" TYPEFLAGS=-DUSE_SIMD=1 -msse\n"
"endif\n"
"\n"
"\n"
"ifeq  \"$(DATATYPE)\" \"float\"\n"
" # fftw needs to be built with --enable-float to build this lib\n"
" FFTWLIB=-lfftw3f\n"
"else\n"
" FFTWLIB=-lfftw3\n"
"endif\n"
"\n"
"FFTWLIBDIR=-L/usr/local/lib/\n"
"\n"
"SRCFILES=../kiss_fft.c ../tools/kiss_fftnd.c ../tools/kiss_fftr.c pstats.c ../tools/kfc.c ../tools/kiss_fftndr.c\n"
"\n"
"all: tools $(BENCHKISS) $(SELFTEST) $(BENCHFFTW) $(TESTREAL) $(TESTKFC)\n"
"\n"
"tools:\n"
"\tcd ../tools && make all\n"
"\n"
"\n"
"$(SELFTEST): $(SELFTESTSRC) $(SRCFILES)\n"
"\t$(CC) -o $@ $(CFLAGS) $(TYPEFLAGS) $+ -lm \n"
"\n"
"$(TESTKFC): $(SRCFILES) \n"
"\t$(CC) -o $@ $(CFLAGS)  -DKFC_TEST $(TYPEFLAGS) $+ -lm\n"
"\t\n"
"$(TESTREAL): test_real.c $(SRCFILES)\n"
"\t$(CC) -o $@ $(CFLAGS) $(TYPEFLAGS) $+ -lm\n"
"\n"
"$(BENCHKISS): benchkiss.c $(SRCFILES)\n"
"\t$(CC) -o $@ $(CFLAGS) $(TYPEFLAGS)  $+ -lm\n"
"\n"
"$(BENCHFFTW): benchfftw.c pstats.c\n"
"\t@echo \"======attempting to build FFTW benchmark\"\n"
"\t@$(CC) -o $@ $(CFLAGS) -DDATATYPE$(DATATYPE) $+ $(FFTWLIB) $(FFTWLIBDIR) -lm || echo \"FFTW not available for comparison\"\n"
"\n"
"test: all\n"
"\t@./$(TESTKFC)\n"
"\t@echo \"======1d & 2-d complex fft self test (type= $(DATATYPE) )\"\n"
"\t@./$(SELFTEST)\n"
"\t@echo \"======real FFT (type= $(DATATYPE) )\"\n"
"\t@./$(TESTREAL)\n"
"\t@echo \"======timing test (type=$(DATATYPE))\"\n"
"\t@./$(BENCHKISS) -x $(NUMFFTS) -n $(NFFT) \n"
"\t@[ -x ./$(BENCHFFTW) ] && ./$(BENCHFFTW) -x $(NUMFFTS) -n $(NFFT) ||true\n"
"\t@echo \"======higher dimensions type=$(DATATYPE))\"\n"
"\t@./testkiss.py\n"
"\n"
"selftest.c:\n"
"\t./mk_test.py 10 12 14 > selftest.c\n"
"selftest_short.c:\n"
"\t./mk_test.py -s 10 12 14 > selftest_short.c\n"
"\n"
"\n"
"CXXFLAGS=-O3 -ffast-math -fomit-frame-pointer  -I.. -I../tools -W -Wall\n"
"testcpp: testcpp.cc ../kissfft.hh\n"
"\t$(CXX) -o $@ $(CXXFLAGS) testcpp.cc -lm\n"
"\n"
"\n"
"clean:\n"
"\trm -f *~ bm_* st_* tr_* kf_* tkfc_* ff_* ffr_* *.pyc *.pyo *.dat testcpp\n";

const char* Makefile2 = (const char*) temp_binary_data_8;

//================== mk_test.py ==================
static const unsigned char temp_binary_data_9[] =
"#!/usr/bin/env python\n"
"\n"
"import FFT\n"
"import sys\n"
"import random\n"
"import re\n"
"j=complex(0,1)\n"
"\n"
"def randvec(n,iscomplex):\n"
"    if iscomplex:\n"
"        return [\n"
"                int(random.uniform(-32768,32767) ) + j*int(random.uniform(-32768,32767) )\n"
"                for i in range(n) ]\n"
"    else:                \n"
"        return [ int(random.uniform(-32768,32767) ) for i in range(n) ]\n"
"    \n"
"def c_format(v,round=0):\n"
"    if round:\n"
"        return ','.join( [ '{%d,%d}' %(int(c.real),int(c.imag) ) for c in v ] ) \n"
"    else:\n"
"        s= ','.join( [ '{%.60f ,%.60f }' %(c.real,c.imag) for c in v ] ) \n"
"        return re.sub(r'\\.?0+ ',' ',s)\n"
"\n"
"def test_cpx( n,inverse ,short):\n"
"    v = randvec(n,1)\n"
"    scale = 1\n"
"    if short:\n"
"        minsnr=30\n"
"    else:\n"
"        minsnr=100\n"
"\n"
"    if inverse:\n"
"        tvecout = FFT.inverse_fft(v)\n"
"        if short:\n"
"            scale = 1\n"
"        else:            \n"
"            scale = len(v)\n"
"    else:\n"
"        tvecout = FFT.fft(v)\n"
"        if short:\n"
"            scale = 1.0/len(v)\n"
"\n"
"    tvecout = [ c * scale for c in tvecout ]\n"
"\n"
"\n"
"    s=\"\"\"#define NFFT %d\"\"\" % len(v) + \"\"\"\n"
"    {\n"
"        double snr;\n"
"        kiss_fft_cpx test_vec_in[NFFT] = { \"\"\"  + c_format(v) + \"\"\"};\n"
"        kiss_fft_cpx test_vec_out[NFFT] = {\"\"\"  + c_format( tvecout ) + \"\"\"};\n"
"        kiss_fft_cpx testbuf[NFFT];\n"
"        void * cfg = kiss_fft_alloc(NFFT,%d,0,0);\"\"\" % inverse + \"\"\"\n"
"\n"
"        kiss_fft(cfg,test_vec_in,testbuf);\n"
"        snr = snr_compare(test_vec_out,testbuf,NFFT);\n"
"        printf(\"DATATYPE=\" xstr(kiss_fft_scalar) \", FFT n=%d, inverse=%d, snr = %g dB\\\\n\",NFFT,\"\"\" + str(inverse) + \"\"\",snr);\n"
"        if (snr<\"\"\" + str(minsnr) + \"\"\")\n"
"            exit_code++;\n"
"        free(cfg);\n"
"    }\n"
"#undef NFFT    \n"
"\"\"\"\n"
"    return s\n"
"\n"
"def compare_func():\n"
"    s=\"\"\"\n"
"#define xstr(s) str(s)\n"
"#define str(s) #s\n"
"double snr_compare( kiss_fft_cpx * test_vec_out,kiss_fft_cpx * testbuf, int n)\n"
"{\n"
"    int k;\n"
"    double sigpow,noisepow,err,snr,scale=0;\n"
"    kiss_fft_cpx err;\n"
"    sigpow = noisepow = .000000000000000000000000000001; \n"
"\n"
"    for (k=0;k<n;++k) {\n"
"        sigpow += test_vec_out[k].r * test_vec_out[k].r + \n"
"                  test_vec_out[k].i * test_vec_out[k].i;\n"
"        C_SUB(err,test_vec_out[k],testbuf[k].r);\n"
"        noisepow += err.r * err.r + err.i + err.i;\n"
"\n"
"        if (test_vec_out[k].r)\n"
"            scale += testbuf[k].r / test_vec_out[k].r;\n"
"    }\n"
"    snr = 10*log10( sigpow / noisepow );\n"
"    scale /= n;\n"
"    if (snr<10)\n"
"        printf( \"\\\\npoor snr, try a scaling factor %f\\\\n\" , scale );\n"
"    return snr;\n"
"}\n"
"\"\"\"\n"
"    return s\n"
"\n"
"def main():\n"
"\n"
"    from getopt import getopt\n"
"    opts,args = getopt(sys.argv[1:],'s')\n"
"    opts = dict(opts)\n"
"    short = int( opts.has_key('-s') )\n"
"\n"
"    fftsizes = args\n"
"    if not fftsizes:\n"
"        fftsizes = [ 1800 ]\n"
"    print '#include \"kiss_fft.h\"'\n"
"    print compare_func()\n"
"    print \"int main() { int exit_code=0;\\n\"\n"
"    for n in fftsizes:\n"
"        n = int(n)\n"
"        print test_cpx(n,0,short)\n"
"        print test_cpx(n,1,short)\n"
"    print \"\"\"\n"
"    return exit_code;\n"
"}\n"
"\"\"\"\n"
"\n"
"if __name__ == \"__main__\":\n"
"    main()\n";

const char* mk_test_py = (const char*) temp_binary_data_9;

//================== testkiss.py ==================
static const unsigned char temp_binary_data_10[] =
"#!/usr/bin/env python\n"
"\n"
"import math\n"
"import sys\n"
"import os\n"
"import random\n"
"import struct\n"
"import popen2\n"
"import getopt\n"
"import numpy\n"
"\n"
"pi=math.pi\n"
"e=math.e\n"
"j=complex(0,1)\n"
"\n"
"doreal=0\n"
"\n"
"datatype = os.environ.get('DATATYPE','float')\n"
"\n"
"util = '../tools/fft_' + datatype\n"
"minsnr=90\n"
"if datatype == 'double':\n"
"    fmt='d'\n"
"elif datatype=='int16_t':\n"
"    fmt='h'\n"
"    minsnr=10\n"
"elif datatype=='int32_t':\n"
"    fmt='i'\n"
"elif datatype=='simd':\n"
"    fmt='4f'\n"
"    sys.stderr.write('testkiss.py does not yet test simd')\n"
"    sys.exit(0)\n"
"elif datatype=='float':\n"
"    fmt='f'\n"
"else:\n"
"    sys.stderr.write('unrecognized datatype %s\\n' % datatype)\n"
"    sys.exit(1)\n"
" \n"
"\n"
"def dopack(x,cpx=1):\n"
"    x = numpy.reshape( x, ( numpy.size(x),) )\n"
"    \n"
"    if cpx:\n"
"        s = ''.join( [ struct.pack(fmt*2,c.real,c.imag) for c in x ] )\n"
"    else:\n"
"        s = ''.join( [ struct.pack(fmt,c.real) for c in x ] )\n"
"    return s\n"
"\n"
"def dounpack(x,cpx):\n"
"    uf = fmt * ( len(x) / struct.calcsize(fmt) )\n"
"    s = struct.unpack(uf,x)\n"
"    if cpx:\n"
"        return numpy.array(s[::2]) + numpy.array( s[1::2] )*j\n"
"    else:\n"
"        return numpy.array(s )\n"
"\n"
"def make_random(dims=[1]):\n"
"    res = []\n"
"    for i in range(dims[0]):\n"
"        if len(dims)==1:\n"
"            r=random.uniform(-1,1)\n"
"            if doreal:\n"
"                res.append( r )\n"
"            else:\n"
"                i=random.uniform(-1,1)\n"
"                res.append( complex(r,i) )\n"
"        else:\n"
"            res.append( make_random( dims[1:] ) )\n"
"    return numpy.array(res)\n"
"\n"
"def flatten(x):\n"
"    ntotal = numpy.size(x)\n"
"    return numpy.reshape(x,(ntotal,))\n"
"\n"
"def randmat( ndims ):\n"
"    dims=[]\n"
"    for i in range( ndims ):\n"
"        curdim = int( random.uniform(2,5) )\n"
"        if doreal and i==(ndims-1):\n"
"            curdim = int(curdim/2)*2 # force even last dimension if real\n"
"        dims.append( curdim )\n"
"    return make_random(dims )\n"
"\n"
"def test_fft(ndims):\n"
"    x=randmat( ndims )\n"
"\n"
"\n"
"    if doreal:\n"
"        xver = numpy.fft.rfftn(x)\n"
"    else:\n"
"        xver = numpy.fft.fftn(x)\n"
"    \n"
"    open('/tmp/fftexp.dat','w').write(dopack( flatten(xver) , True ) )\n"
"\n"
"    x2=dofft(x,doreal)\n"
"    err = xver - x2\n"
"    errf = flatten(err)\n"
"    xverf = flatten(xver)\n"
"    errpow = numpy.vdot(errf,errf)+1e-10\n"
"    sigpow = numpy.vdot(xverf,xverf)+1e-10\n"
"    snr = 10*math.log10(abs(sigpow/errpow) )\n"
"    print 'SNR (compared to NumPy) : %.1fdB' % float(snr)\n"
"\n"
"    if snr<minsnr:\n"
"        print 'xver=',xver\n"
"        print 'x2=',x2\n"
"        print 'err',err\n"
"        sys.exit(1)\n"
" \n"
"def dofft(x,isreal):\n"
"    dims=list( numpy.shape(x) )\n"
"    x = flatten(x)\n"
"\n"
"    scale=1\n"
"    if datatype=='int16_t':\n"
"        x = 32767 * x\n"
"        scale = len(x) / 32767.0\n"
"    elif datatype=='int32_t':\n"
"        x = 2147483647.0 * x\n"
"        scale = len(x) / 2147483647.0\n"
"\n"
"    cmd='%s -n ' % util\n"
"    cmd += ','.join([str(d) for d in dims])\n"
"    if doreal:\n"
"        cmd += ' -R '\n"
"\n"
"    print cmd\n"
"    p = popen2.Popen3(cmd )\n"
"\n"
"    open('/tmp/fftin.dat','w').write(dopack( x , isreal==False ) )\n"
"\n"
"    p.tochild.write( dopack( x , isreal==False ) )\n"
"    p.tochild.close()\n"
"\n"
"    res = dounpack( p.fromchild.read() , 1 )\n"
"    open('/tmp/fftout.dat','w').write(dopack( flatten(res) , True ) )\n"
"    if doreal:\n"
"        dims[-1] = int( dims[-1]/2 ) + 1\n"
"\n"
"    res = scale * res\n"
"\n"
"    p.wait()\n"
"    return numpy.reshape(res,dims)\n"
"\n"
"def main():\n"
"    opts,args = getopt.getopt(sys.argv[1:],'r')\n"
"    opts=dict(opts)\n"
"\n"
"    global doreal\n"
"    doreal = opts.has_key('-r')\n"
"\n"
"    if doreal:\n"
"        print 'Testing multi-dimensional real FFTs'\n"
"    else:\n"
"        print 'Testing multi-dimensional FFTs'\n"
"\n"
"    for dim in range(1,4):\n"
"        test_fft( dim )\n"
"\n"
"if __name__ == \"__main__\":\n"
"    main()\n"
"\n";

const char* testkiss_py = (const char*) temp_binary_data_10;

//================== TIPS ==================
static const unsigned char temp_binary_data_11[] =
"Speed:\n"
"    * If you want to use multiple cores, then compile with -openmp or -fopenmp (see your compiler docs).\n"
"\tRealize that larger FFTs will reap more benefit than smaller FFTs. This generally uses more CPU time, but\n"
"\tless wall time.\n"
"\n"
"    * experiment with compiler flags\n"
"        Special thanks to Oscar Lesta. He suggested some compiler flags \n"
"        for gcc that make a big difference. They shave 10-15% off\n"
"        execution time on some systems.  Try some combination of:\n"
"                -march=pentiumpro\n"
"                -ffast-math\n"
"                -fomit-frame-pointer\n"
"\n"
"    * If the input data has no imaginary component, use the kiss_fftr code under tools/.\n"
"      Real ffts are roughly twice as fast as complex.\n"
"\n"
"    * If you can rearrange your code to do 4 FFTs in parallel and you are on a recent Intel or AMD machine,\n"
"    then you might want to experiment with the USE_SIMD code.  See README.simd\n"
"\n"
"\n"
"Reducing code size:\n"
"    * remove some of the butterflies. There are currently butterflies optimized for radices\n"
"        2,3,4,5.  It is worth mentioning that you can still use FFT sizes that contain \n"
"        other factors, they just won't be quite as fast.  You can decide for yourself \n"
"        whether to keep radix 2 or 4.  If you do some work in this area, let me \n"
"        know what you find.\n"
"\n"
"    * For platforms where ROM/code space is more plentiful than RAM,\n"
"     consider creating a hardcoded kiss_fft_state. In other words, decide which \n"
"     FFT size(s) you want and make a structure with the correct factors and twiddles.\n"
"\n"
"    * Frank van der Hulst offered numerous suggestions for smaller code size and correct operation \n"
"    on embedded targets.  \"I'm happy to help anyone who is trying to implement KISSFFT on a micro\"\n"
"\n"
"    Some of these were rolled into the mainline code base:\n"
"        - using long casts to promote intermediate results of short*short multiplication\n"
"        - delaying allocation of buffers that are sometimes unused.\n"
"    In some cases, it may be desirable to limit capability in order to better suit the target:\n"
"        - predefining the twiddle tables for the desired fft size.  \n";

const char* TIPS = (const char*) temp_binary_data_11;

//================== Makefile ==================
static const unsigned char temp_binary_data_12[] =
"WARNINGS=-W -Wall -Wstrict-prototypes -Wmissing-prototypes -Waggregate-return \\\n"
"    -Wcast-align -Wcast-qual -Wnested-externs -Wshadow -Wbad-function-cast \\\n"
"    -Wwrite-strings\n"
"\n"
"ifeq \"$(DATATYPE)\" \"\"\n"
" DATATYPE=float\n"
"endif\n"
"\n"
"ifeq  \"$(DATATYPE)\" \"int32_t\"\n"
" TYPEFLAGS=-DFIXED_POINT=32\n"
"endif\n"
"\n"
"ifeq  \"$(DATATYPE)\" \"int16_t\"\n"
" TYPEFLAGS=-DFIXED_POINT=16\n"
"endif\n"
"\n"
"ifeq  \"$(DATATYPE)\" \"simd\"\n"
" TYPEFLAGS=-DUSE_SIMD=1 -msse\n"
"endif\n"
"\n"
"ifeq \"$(TYPEFLAGS)\"  \"\"\n"
" TYPEFLAGS=-Dkiss_fft_scalar=$(DATATYPE)\n"
"endif\n"
"\n"
"ifneq (\"$(KISS_FFT_USE_ALLOCA)\",\"\")\n"
"\tCFLAGS+= -DKISS_FFT_USE_ALLOCA=1\n"
"endif \n"
"CFLAGS+= $(CFLAGADD)\n"
"\n"
"\n"
"FFTUTIL=fft_$(DATATYPE)\n"
"FASTFILT=fastconv_$(DATATYPE)\n"
"FASTFILTREAL=fastconvr_$(DATATYPE)\n"
"PSDPNG=psdpng_$(DATATYPE)\n"
"DUMPHDR=dumphdr_$(DATATYPE)\n"
"\n"
"all: $(FFTUTIL) $(FASTFILT) $(FASTFILTREAL) \n"
"# \t$(PSDPNG) \n"
"#\t$(DUMPHDR)\n"
"\n"
"#CFLAGS=-Wall -O3 -pedantic -march=pentiumpro -ffast-math -fomit-frame-pointer $(WARNINGS)\n"
"# If the above flags do not work, try the following\n"
"CFLAGS=-Wall -O3 $(WARNINGS) \n"
"# tip: try -openmp or -fopenmp to use multiple cores\n"
"\n"
"$(FASTFILTREAL): ../kiss_fft.c kiss_fastfir.c kiss_fftr.c\n"
"\t$(CC) -o $@ $(CFLAGS) -I.. $(TYPEFLAGS) -DREAL_FASTFIR  $+ -DFAST_FILT_UTIL -lm \n"
"\n"
"$(FASTFILT): ../kiss_fft.c kiss_fastfir.c\n"
"\t$(CC) -o $@ $(CFLAGS) -I.. $(TYPEFLAGS) $+  -DFAST_FILT_UTIL -lm\n"
"\n"
"$(FFTUTIL): ../kiss_fft.c fftutil.c kiss_fftnd.c kiss_fftr.c kiss_fftndr.c\n"
"\t$(CC) -o $@ $(CFLAGS) -I.. $(TYPEFLAGS) $+ -lm\n"
"\n"
"$(PSDPNG): ../kiss_fft.c psdpng.c kiss_fftr.c\n"
"\t$(CC) -o $@ $(CFLAGS) -I.. $(TYPEFLAGS) $+ -lpng -lm\n"
"\n"
"$(DUMPHDR): ../kiss_fft.c dumphdr.c\n"
"\t$(CC) -o $@ $(CFLAGS) -I.. $(TYPEFLAGS) $+ -lm\n"
"\n"
"clean:\n"
"\trm -f *~ fft fft_* fastconv fastconv_* fastconvr fastconvr_* psdpng psdpng_*\n";

const char* Makefile3 = (const char*) temp_binary_data_12;

//================== CHANGES ==================
static const unsigned char temp_binary_data_13[] =
"April 9, 2013\r\n"
"-------------\r\n"
"\r\n"
"Changes for the 1.1.0 release (vs 1.0.2) are listed below. Unless\r\n"
"otherwise indicated these changes have been made since \r\n"
"January 2013. The focus has been on general clean-up, fixing bugs,\r\n"
"compiler errors and warnings, and fixing issues on 64 bit platforms. \r\n"
"A few improvements such as support for OSC arrays, functions\r\n"
"for setting broadcast and reuse socket options have been added.\r\n"
"This update merges changes from the openFrameworks version \r\n"
"of oscpack.\r\n"
"\r\n"
"    - Added support for arrays in messages (see OscUnitTests.cpp \r\n"
"    for example usage). (patch thanks to Tim Blechmann)\r\n"
"    \r\n"
"    - Fixed bugs relating to 64 bit usage (e.g. crashes in 64 bit \r\n"
"    builds on OS X).\r\n"
"   \t\r\n"
"    - Some member functions that previously used the \"int\" or\r\n"
"    \"unsigned long\" type for parameters or return values now use \r\n"
"    std::size_t (platform-defined) or \r\n"
"    osc_bundle_element_size_t (a.k.a. int32).   \r\n"
"    This change  was made to better support 64 bit platforms.\r\n"
"    See SVN revision 70 for details.\r\n"
"    \r\n"
"    - The previous point introduces a breaking change on Linux/x86_64\r\n"
"    for callers of AsBlob() and AsBlobUnchecked():\r\n"
"    The type of the second argument (the \"size\" argument) to\r\n"
"    ReceivedMessageArgument::AsBlob() and \r\n"
"    ReceivedMessageArgument::AsBlobUnchecked() has changed\r\n"
"    from unsigned long & to osc_bundle_element_size_t (an int32). \r\n"
"    You should declare your size argument variables as \r\n"
"    osc_bundle_element_size_t to avoid incompatibilities between \r\n"
"    32 and 64 bit builds.\r\n"
"\r\n"
"    - Note that oscpack does not support packets larger than\r\n"
"    0x7FFFFFFC (see comments in class ReceivedPacket for\r\n"
"    details).\r\n"
"    \r\n"
"    - Oscpack defines an osc::Nil value used for sending the nil \r\n"
"    message argument value. This conflicts with Objective-C. \r\n"
"    Therefore osc::Nil is no longer defined in  Obj-C++ code. \r\n"
"    There is now an osc::OscNil value, which should be preferred. \r\n"
"    osc::Nil is still available when writing C++.\r\n"
"    (fix thanks to openFrameworks)\r\n"
"    \r\n"
"    - Added UdpSocket::SetEnableBroadcast(). This needs to \r\n"
"    be called to enable sending to the broadcast address on some\r\n"
"    platforms (e.g. Mac OS X). (thanks to openFrameworks)\r\n"
"    \r\n"
"    - Added UdpSocket::SetAllowReuse(). This is useful for \r\n"
"    sharing sockets on some platforms (Mac?), and not so useful \r\n"
"    on other platforms. (thanks to openFrameworks)\r\n"
"    \r\n"
"    - Added IpEndpointName::IsMulticastAddress() (2010)\r\n"
"    \r\n"
"    - Cleaned up C++ header usage and std:: namespace usage\r\n"
"    to be more standards compliant (fixes issues on recent compilers\r\n"
"    such as clang and gcc4.6).\r\n"
"   \t\r\n"
"    - Improved host endianness detection. Should auto-detect\r\n"
"    endianness on most platforms now.\r\n"
"    (thanks to Tim Blechmann for help with this)\r\n"
"    \r\n"
"    - Fixed two memory leaks: (1) in OscPrintReceivedElements.cpp\r\n"
"    when printing time tag message arguments (thanks to Gwydion ap Dafydd). \r\n"
"    (2) in the posix SocketReceiveMultiplexer::Run() method if an exception \r\n"
"    was thrown while listening.\r\n"
"    \r\n"
"    - Fixed bug in posix SocketReceiveMultiplexer::Run() that would cause \r\n"
"    packets to stop being received if select() returned EINTR. \r\n"
"    (thanks to Bj\xf6rn W\xf6ldecke)\r\n"
"    \r\n"
"    - Updated and improved Makefile to avoid redundant re-linking\r\n"
"    (thanks to Douglas Mandell)\r\n"
"   \r\n"
"    - Added CMakeLists.txt CMake build file (2010, thanks to David Doria)\r\n"
"     \r\n"
"    - Switched license to plain MIT license with non binding request\r\n"
"    for contribution of improvements (same as current PortAudio \r\n"
"    boilerplate). See LICENSE file.\r\n"
"\r\n"
"Thanks to Tim Blechmann, Rob Canning, Gwydion ap Dafydd, David Doria, \r\n"
"Christopher Delaney, Jon McCormack, Douglas Mandell, Bj\xf6rn W\xf6ldecke,\r\n"
"all the guys at openFrameworks, and everyone who reported bugs, \r\n"
"submitted patches and helped out with testing this release.\r\n"
"\r\n"
"Thanks to Syneme at the University of Calgary for providing financial \r\n"
"support for the 1.1.0 update.\r\n"
"\r\n"
"\r\n"
"September 28, 2005\r\n"
"------------------\r\n"
"\r\n"
"Compared to the previous official snapshot (November 2004) the \r\n"
"current version of oscpack includes a re-written set of network \r\n"
"classes and some changes to the syntax of the networking code. It no \r\n"
"longer uses threads, which means that you don't need to use sleep() \r\n"
"if you are writing a simple single-threaded server, or you need to \r\n"
"spawn your own threads in a more complex application.\r\n"
"\r\n"
"The list below summarises the changes if you are porting code from \r\n"
"the previous release.\r\n"
"\r\n"
"    - There are no longer any threads in oscpack. if you need to \r\n"
"    set up an asynchronous listener you can create your own thread \r\n"
"    and call Run on an instance of SocketReceiveMultiplexer or \r\n"
"    UdpListeningReceiveSocket (see ip/UdpSocket.h) yourself.\r\n"
"    \r\n"
"    - Host byte order is now used for network (IP) addresses\r\n"
"        \r\n"
"    - Functions which used to take two parameters <address, port> \r\n"
"    now take an instance of IpEndpointName (see \r\n"
"    ip/IpEndpointName.h) this class has a number of convenient \r\n"
"    constructors for converting numbers and strings to internet \r\n"
"    addresses. For example there is one which takes a string and \r\n"
"    another that take the dotted address components as separate \r\n"
"    parameters.\r\n"
"    \r\n"
"    - The UdpTransmitPort class, formerly in UdpTransmitPort.h, is \r\n"
"    now called UdpTransmitSocket, which is simply a convenience \r\n"
"    class derived from UdpSocket (see ip/UdpSocket.h). Where you \r\n"
"    used to use the constructor UdpTransmitPort( address, port) now \r\n"
"    you can use UdpTransmitSocket( IpEndpointName( address, port ) \r\n"
"    ) or you can any of the other possible ctors to IpEndpointName\r\n"
"    () (see above). The Send() method is unchanged.\r\n"
"    \r\n"
"    - The packet listener base class is now located in \r\n"
"    ip/PacketListener.h instead of PacketListenerPort.h. The \r\n"
"    ProcessPacket method now has an additional parameter indicating \r\n"
"    the remote endpoint\r\n"
"    \r\n"
"    - The preferred way to set up listeners is with \r\n"
"    SocketReceiveMultiplexer (in ip/UdpSocket.h), this also allows \r\n"
"    attaching periodic timers. For simple applications which only \r\n"
"    listen to a single socket with no timers you can use \r\n"
"    UdpListeningReceiveSocket (also in UdpSocket.h) See \r\n"
"    osc/OscReceiveTest.cpp or osc/OscDump.cpp for examples of this. \r\n"
"    This is more or less equivalent to the UdpPacketListenerPort \r\n"
"    object in the old oscpack versions except that you need to \r\n"
"    explicitly call Run() before it will start receiving packets \r\n"
"    and it runs in the same thread, not a separate thread so Run() \r\n"
"    won't usually return.\r\n"
"    \r\n"
"    - Explicit calls to InitializeNetworking() and \r\n"
"    TerminateNetworking() are no longer required for simple \r\n"
"    applications (more complex windows applications should \r\n"
"    instantiate NetworkInitializer in main() or WinMain (see \r\n"
"    ip/NetworkingUtils.h/.cpp)\r\n"
"    \r\n"
"    - The OscPacketListener base class (OscPacketListener.h) was \r\n"
"    added to make traversing OSC packets easier, it handles bundle \r\n"
"    traversal automatically so you only need to process messages in \r\n"
"    your derived classes.\r\n"
"    \r\n"
"    - On Windows be sure to link with ws2_32.lib or you will see\r\n"
"    a linker error about WSAEventSelect not being found. Also you \r\n"
"    will need to link with winmm.lib for timeGetTime()\r\n"
"\r\n";

const char* CHANGES = (const char*) temp_binary_data_13;

//================== CMakeLists.txt ==================
static const unsigned char temp_binary_data_14[] =
"cmake_minimum_required(VERSION 2.6)\n"
"PROJECT(TestOscpack)\n"
"\n"
"INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR})\n"
"\n"
"# separate versions of NetworkingUtils.cpp and UdpSocket.cpp are provided for Win32 and POSIX\n"
"# the IpSystemTypePath selects the correct ones based on the current platform\n"
"\n"
"IF(WIN32)\n"
" set(IpSystemTypePath ip/win32)\n"
" set(LIBS ${LIBS} Ws2_32 winmm)\n"
"ELSE(WIN32)\n"
" set(IpSystemTypePath ip/posix)\n"
"ENDIF(WIN32)\n"
"\n"
"ADD_LIBRARY(oscpack \n"
"\n"
"ip/IpEndpointName.h\n"
"ip/IpEndpointName.cpp\n"
"\n"
"ip/NetworkingUtils.h\n"
"${IpSystemTypePath}/NetworkingUtils.cpp\n"
"\n"
"ip/UdpSocket.h\n"
"${IpSystemTypePath}/UdpSocket.cpp\n"
"\n"
"ip/PacketListener.h\n"
"ip/TimerListener.h\n"
"\n"
"osc/OscTypes.h\n"
"osc/OscTypes.cpp \n"
"osc/OscHostEndianness.h\n"
"osc/OscException.h\n"
"osc/OscPacketListener.h\n"
"osc/MessageMappingOscPacketListener.h\n"
"osc/OscReceivedElements.h\n"
"osc/OscReceivedElements.cpp\n"
"osc/OscPrintReceivedElements.h\n"
"osc/OscPrintReceivedElements.cpp\n"
"osc/OscOutboundPacketStream.h\n"
"osc/OscOutboundPacketStream.cpp\n"
"\n"
")\n"
"\n"
"\n"
"ADD_EXECUTABLE(OscUnitTests tests/OscUnitTests.cpp)\n"
"TARGET_LINK_LIBRARIES(OscUnitTests oscpack ${LIBS})\n"
"\n"
"ADD_EXECUTABLE(OscSendTests tests/OscSendTests.cpp)\n"
"TARGET_LINK_LIBRARIES(OscSendTests oscpack ${LIBS})\n"
"\n"
"ADD_EXECUTABLE(OscReceiveTest tests/OscReceiveTest.cpp)\n"
"TARGET_LINK_LIBRARIES(OscReceiveTest oscpack ${LIBS})\n"
"\n"
"\n"
"ADD_EXECUTABLE(OscDump examples/OscDump.cpp)\n"
"TARGET_LINK_LIBRARIES(OscDump oscpack ${LIBS})\n"
"\n"
"ADD_EXECUTABLE(SimpleReceive examples/SimpleReceive.cpp)\n"
"TARGET_LINK_LIBRARIES(SimpleReceive oscpack ${LIBS})\n"
"\n"
"ADD_EXECUTABLE(SimpleSend examples/SimpleSend.cpp)\n"
"TARGET_LINK_LIBRARIES(SimpleSend oscpack ${LIBS})\n"
"\n"
"\n"
"if(MSVC)\n"
"  # Force to always compile with W4\n"
"  if(CMAKE_CXX_FLAGS MATCHES \"/W[0-4]\")\n"
"    string(REGEX REPLACE \"/W[0-4]\" \"/W4\" CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS}\")\n"
"  else()\n"
"    set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} /W4\")\n"
"  endif()\n"
"elseif(CMAKE_COMPILER_IS_GNUCC OR CMAKE_COMPILER_IS_GNUCXX)\n"
"  # Update if necessary\n"
"  set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -Wall -Wextra -Wno-long-long -pedantic\")\n"
"endif()\n";

const char* CMakeLists_txt = (const char*) temp_binary_data_14;

//================== LICENSE ==================
static const unsigned char temp_binary_data_15[] =
"oscpack -- Open Sound Control (OSC) packet manipulation library\r\n"
"http://www.rossbencina.com/code/oscpack\r\n"
"\r\n"
"Copyright (c) 2004-2013 Ross Bencina <rossb@audiomulch.com>\r\n"
"\r\n"
"Permission is hereby granted, free of charge, to any person obtaining\r\n"
"a copy of this software and associated documentation files\r\n"
"(the \"Software\"), to deal in the Software without restriction,\r\n"
"including without limitation the rights to use, copy, modify, merge,\r\n"
"publish, distribute, sublicense, and/or sell copies of the Software,\r\n"
"and to permit persons to whom the Software is furnished to do so,\r\n"
"subject to the following conditions:\r\n"
"\r\n"
"The above copyright notice and this permission notice shall be\r\n"
"included in all copies or substantial portions of the Software.\r\n"
"\r\n"
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n"
"EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n"
"MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\n"
"IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR\r\n"
"ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\r\n"
"CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n"
"WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n"
"\r\n"
"###\r\n"
"\r\n"
"The text above constitutes the entire oscpack license; however, \r\n"
"the oscpack developer(s) also make the following non-binding requests:\r\n"
"\r\n"
"Any person wishing to distribute modifications to the Software is\r\n"
"requested to send the modifications to the original developer so that\r\n"
"they can be incorporated into the canonical version. It is also \r\n"
"requested that these non-binding requests be included whenever the\r\n"
"above license is reproduced.";

const char* LICENSE = (const char*) temp_binary_data_15;

//================== make.MinGW32.bat ==================
static const unsigned char temp_binary_data_16[] =
"del bin\\OscUnitTests.exe\r\n"
"del bin\\OscDump.exe\r\n"
"del bin\\OscSendTests.exe\r\n"
"del bin\\OscReceiveTest.exe\r\n"
"mkdir bin\r\n"
"\r\n"
"g++ tests\\OscUnitTests.cpp osc\\OscTypes.cpp osc\\OscReceivedElements.cpp osc\\OscPrintReceivedElements.cpp osc\\OscOutboundPacketStream.cpp -Wall -Wextra -I. -lws2_32 -o bin\\OscUnitTests.exe\r\n"
"\r\n"
"g++ examples\\OscDump.cpp osc\\OscTypes.cpp osc\\OscReceivedElements.cpp osc\\OscPrintReceivedElements.cpp ip\\win32\\NetworkingUtils.cpp ip\\win32\\UdpSocket.cpp -Wall -Wextra -I. -lws2_32 -lwinmm -o bin\\OscDump.exe\r\n"
"\r\n"
"g++ examples\\SimpleSend.cpp osc\\OscTypes.cpp osc\\OscOutboundPacketStream.cpp ip\\win32\\NetworkingUtils.cpp ip\\win32\\UdpSocket.cpp ip\\IpEndpointName.cpp -Wall -Wextra -I. -lws2_32 -lwinmm -o bin\\SimpleSend.exe\r\n"
"\r\n"
"g++ examples\\SimpleReceive.cpp osc\\OscTypes.cpp osc\\OscReceivedElements.cpp ip\\win32\\NetworkingUtils.cpp ip\\win32\\UdpSocket.cpp -Wall -Wextra -I. -lws2_32 -lwinmm -o bin\\SimpleReceive.exe\r\n"
"\r\n"
"g++ tests\\OscSendTests.cpp osc\\OscTypes.cpp osc\\OscOutboundPacketStream.cpp ip\\win32\\NetworkingUtils.cpp ip\\win32\\UdpSocket.cpp ip\\IpEndpointName.cpp -Wall -Wextra -I. -lws2_32 -lwinmm -o bin\\OscSendTests.exe\r\n"
"\r\n"
"g++ tests\\OscReceiveTest.cpp osc\\OscTypes.cpp osc\\OscReceivedElements.cpp ip\\win32\\NetworkingUtils.cpp ip\\win32\\UdpSocket.cpp -Wall -Wextra -I. -lws2_32 -lwinmm -o bin\\OscReceiveTest.exe\r\n"
"\r\n"
".\\bin\\OscUnitTests.exe";

const char* make_MinGW32_bat = (const char*) temp_binary_data_16;

//================== Makefile ==================
static const unsigned char temp_binary_data_17[] =
"# oscpack makefile\r\n"
"\r\n"
"# the source code should auto-detect endianess for most systems\r\n"
"# (see osc/OscHostEndianness.h)\r\n"
"# otherwise you need to explicitly set ENDIANESS below\r\n"
"# to either OSC_HOST_BIG_ENDIAN or OSC_HOST_LITTLE_ENDIAN\r\n"
"# Apple Mac OS X (PowerPC): OSC_HOST_BIG_ENDIAN\r\n"
"# Apple Mac OS X (Intel): OSC_HOST_LITTLE_ENDIAN\r\n"
"# Win32: OSC_HOST_LITTLE_ENDIAN\r\n"
"# i386 GNU/Linux: OSC_HOST_LITTLE_ENDIAN\r\n"
"\r\n"
"ENDIANESS=OSC_DETECT_ENDIANESS #source code will detect using preprocessor\r\n"
"#ENDIANESS=OSC_HOST_LITTLE_ENDIAN\r\n"
"\r\n"
"UNAME := $(shell uname)\r\n"
"\r\n"
"CXX := g++\r\n"
"INCLUDES := -I.\r\n"
"COPTS  := -Wall -Wextra -O3\r\n"
"CDEBUG := -Wall -Wextra -g \r\n"
"CXXFLAGS := $(COPTS) $(INCLUDES) -D$(ENDIANESS)\r\n"
"\r\n"
"BINDIR := bin\r\n"
"PREFIX := /usr/local\r\n"
"INSTALL := install -c\r\n"
"\r\n"
"#Name definitions\r\n"
"UNITTESTS := $(BINDIR)/OscUnitTests\r\n"
"SENDTESTS := $(BINDIR)/OscSendTests\r\n"
"RECEIVETEST := $(BINDIR)/OscReceiveTest\r\n"
"SIMPLESEND := $(BINDIR)/SimpleSend\r\n"
"SIMPLERECEIVE := $(BINDIR)/SimpleReceive\r\n"
"DUMP := $(BINDIR)/OscDump\r\n"
"\r\n"
"INCLUDEDIR := oscpack\r\n"
"LIBNAME := liboscpack\r\n"
"LIBSONAME := $(LIBNAME).so\r\n"
"LIBFILENAME := $(LIBSONAME).1.1.0\r\n"
"\r\n"
"# Common source groups\r\n"
"\r\n"
"RECEIVESOURCES := osc/OscReceivedElements.cpp osc/OscPrintReceivedElements.cpp\r\n"
"SENDSOURCES := osc/OscOutboundPacketStream.cpp\r\n"
"NETSOURCES := ip/posix/UdpSocket.cpp ip/IpEndpointName.cpp ip/posix/NetworkingUtils.cpp\r\n"
"COMMONSOURCES := osc/OscTypes.cpp\r\n"
"\r\n"
"RECEIVEOBJECTS := $(RECEIVESOURCES:.cpp=.o)\r\n"
"SENDOBJECTS := $(SENDSOURCES:.cpp=.o)\r\n"
"NETOBJECTS := $(NETSOURCES:.cpp=.o)\r\n"
"COMMONOBJECTS := $(COMMONSOURCES:.cpp=.o)\r\n"
"\r\n"
"# Test source\r\n"
"\r\n"
"UNITTESTSOURCES := tests/OscUnitTests.cpp\r\n"
"UNITTESTOBJECTS := $(UNITTESTSOURCES:.cpp=.o)\r\n"
"\r\n"
"SENDTESTSSOURCES := tests/OscSendTests.cpp\r\n"
"SENDTESTSOBJECTS := $(SENDTESTSSOURCES:.cpp=.o)\r\n"
"\r\n"
"RECEIVETESTSOURCES := tests/OscReceiveTest.cpp\r\n"
"RECEIVETESTOBJECTS := $(RECEIVETESTSOURCES:.cpp=.o)\r\n"
"\r\n"
"# Example source\r\n"
"\r\n"
"SIMPLESENDSOURCES := examples/SimpleSend.cpp\r\n"
"SIMPLESENDOBJECTS := $(SIMPLESENDSOURCES:.cpp=.o)\r\n"
"\r\n"
"SIMPLERECEIVESOURCES := examples/SimpleReceive.cpp\r\n"
"SIMPLERECEIVEOBJECTS := $(SIMPLERECEIVESOURCES:.cpp=.o)\r\n"
"\r\n"
"DUMPSOURCES := examples/OscDump.cpp\r\n"
"DUMPOBJECTS := $(DUMPSOURCES:.cpp=.o)\r\n"
"\r\n"
"#Library objects\r\n"
"\r\n"
"LIBOBJECTS := $(COMMONOBJECTS) $(SENDOBJECTS) $(RECEIVEOBJECTS) $(NETOBJECTS)\r\n"
"\r\n"
".PHONY: all unittests sendtests receivetest simplesend simplereceive dump library clean install install-local\r\n"
"\r\n"
"all: unittests sendtests receivetest simplesend simplereceive dump\r\n"
"\r\n"
"unittests : $(UNITTESTS)\r\n"
"sendtests: $(SENDTESTS)\r\n"
"receivetest : $(RECEIVETEST)\r\n"
"simplesend : $(SIMPLESEND)\r\n"
"simplereceive : $(SIMPLERECEIVE)\r\n"
"dump : $(DUMP)\r\n"
"\r\n"
"# Build rule and common dependencies for all programs\r\n"
"# | specifies an order-only dependency so changes to bin dir modified date don't trigger recompile\r\n"
"$(UNITTESTS) $(SENDTESTS) $(RECEIVETEST) $(SIMPLESEND) $(SIMPLERECEIVE) $(DUMP) : $(COMMONOBJECTS) | $(BINDIR)\r\n"
"\t$(CXX) -o $@ $^\r\n"
"\r\n"
"# Additional dependencies for each program (make accumulates dependencies from multiple declarations)\r\n"
"$(UNITTESTS) : $(UNITTESTOBJECTS) $(SENDOBJECTS) $(RECEIVEOBJECTS)\r\n"
"$(SENDTESTS) : $(SENDTESTSOBJECTS) $(SENDOBJECTS) $(NETOBJECTS)\r\n"
"$(RECEIVETEST) : $(RECEIVETESTOBJECTS) $(RECEIVEOBJECTS) $(NETOBJECTS)\r\n"
"$(SIMPLESEND) : $(SIMPLESENDOBJECTS) $(SENDOBJECTS) $(NETOBJECTS)\r\n"
"$(SIMPLERECEIVE) : $(SIMPLERECEIVEOBJECTS) $(RECEIVEOBJECTS) $(NETOBJECTS)\r\n"
"$(DUMP) : $(DUMPOBJECTS) $(RECEIVEOBJECTS) $(NETOBJECTS)\r\n"
"\r\n"
"$(BINDIR):\r\n"
"\tmkdir $@\r\n"
"\r\n"
"clean:\r\n"
"\trm -rf $(BINDIR) $(UNITTESTOBJECTS) $(SENDTESTSOBJECTS) $(RECEIVETESTOBJECTS) $(DUMPOBJECTS) $(LIBOBJECTS) $(SIMPLESENDOBJECTS) $(SIMPLERECEIVEOBJECTS) $(LIBFILENAME) include lib oscpack &> /dev/null\r\n"
"\r\n"
"$(LIBFILENAME): $(LIBOBJECTS)\r\n"
"ifeq ($(UNAME), Darwin)\r\n"
"\t#Mac OS X case\r\n"
"\t$(CXX) -dynamiclib -Wl,-install_name,$(LIBSONAME) -o $(LIBFILENAME) $(LIBOBJECTS) -lc\r\n"
"else\r\n"
"\t#GNU/Linux case\r\n"
"\t$(CXX) -shared -Wl,-soname,$(LIBSONAME) -o $(LIBFILENAME) $(LIBOBJECTS) -lc\r\n"
"endif\r\n"
"\r\n"
"lib: $(LIBFILENAME)\r\n"
"\r\n"
"#Installs the library on a system global location\r\n"
"install: $(LIBFILENAME)\r\n"
"\t@$(INSTALL) -m 755 $(LIBFILENAME) $(PREFIX)/lib/$(LIBFILENAME)\r\n"
"\t@ln -s -f $(PREFIX)/lib/$(LIBFILENAME) $(PREFIX)/lib/$(LIBSONAME) \r\n"
"\t@mkdir  -p $(PREFIX)/include/oscpack/ip $(PREFIX)/include/oscpack/osc\r\n"
"\t@$(INSTALL) -m 644 ip/*.h $(PREFIX)/include/oscpack/ip\r\n"
"\t@$(INSTALL) -m 644 osc/*.h $(PREFIX)/include/oscpack/osc\r\n"
"\t@echo \"SUCCESS! oscpack has been installed in $(PREFIX)/lib and $(PREFIX)/include/ospack/\"\r\n"
"ifneq ($(UNAME), Darwin)\r\n"
"\t@echo \"now doing ldconfig...\"\r\n"
"\t@ldconfig\r\n"
"endif\r\n"
"\r\n"
"#Installs the include/lib structure locally\r\n"
"install-local: $(LIBFILENAME)\r\n"
"\t@echo \"\"\r\n"
"\t@echo \" Installing in local directory <$(INCLUDEDIR)>\"\r\n"
"\t@echo \"   > Creating symbolic link\"\r\n"
"\t@ln -s $(LIBFILENAME) $(LIBSONAME)\r\n"
"\t@echo \"   > Creating directories\"\r\n"
"\t@mkdir -p oscpack/lib\r\n"
"\t@mkdir -p oscpack/include/ip\r\n"
"\t@mkdir -p oscpack/include/osc\r\n"
"\t@echo \"   > Copying files\"\r\n"
"\t@mv $(LIBFILENAME) $(LIBSONAME) oscpack/lib\r\n"
"\t@cp ip/*.h oscpack/include/ip\r\n"
"\t@cp osc/*.h oscpack/include/osc\r\n"
"\t@echo \"\"\r\n"
"\t@echo \"   > Success!\"\r\n"
"\r\n";

const char* Makefile4 = (const char*) temp_binary_data_17;

//================== README ==================
static const unsigned char temp_binary_data_18[] =
"oscpack -- Open Sound Control packet manipulation library\r\n"
"A simple C++ library for packing and unpacking OSC packets.\r\n"
"http://www.rossbencina.com/code/oscpack\r\n"
"\r\n"
"Copyright (c) 2004-2013 Ross Bencina <rossb@audiomulch.com>\r\n"
"\r\n"
"\r\n"
"Oscpack is simply a set of C++ classes for packing and unpacking OSC packets. \r\n"
"Oscpack includes a minimal set of UDP networking classes for Windows and POSIX.\r\n"
"The networking classes are sufficient for writing many OSC applications and servers, \r\n"
"but you are encouraged to use another networking framework if it better suits your needs. \r\n"
"Oscpack is not an OSC application framework. It doesn't include infrastructure for \r\n"
"constructing or routing OSC namespaces, just classes for easily constructing, \r\n"
"sending, receiving and parsing OSC packets. The library should also be easy to use \r\n"
"for other transport methods (e.g. serial).\r\n"
"\r\n"
"The key goals of the oscpack library are:\r\n"
"\r\n"
"    - Be a simple and complete implementation of OSC\r\n"
"    - Be portable to a wide variety of platforms\r\n"
"    - Allow easy development of robust OSC applications \r\n"
"      (for example it should be impossible to crash a server \r\n"
"      by sending it malformed packets, and difficult to create \r\n"
"      malformed packets.)\r\n"
"\r\n"
"Here's a quick run down of the key files:\r\n"
"\r\n"
"osc/OscReceivedElements -- classes for parsing a packet\r\n"
"osc/OscPrintRecievedElements -- iostream << operators for printing packet elements\r\n"
"osc/OscOutboundPacketStream -- a class for packing messages into a packet\r\n"
"osc/OscPacketListener -- base class for listening to OSC packets on a UdpSocket\r\n"
"ip/IpEndpointName -- class that represents an IP address and port number\r\n"
"ip/UdpSocket -- classes for UDP transmission and listening sockets\r\n"
"tests/OscUnitTests -- unit test program for the OSC modules\r\n"
"tests/OscSendTests -- examples of how to send messages\r\n"
"tests/OscReceiveTest -- example of how to receive the messages sent by OSCSendTests\r\n"
"examples/OscDump -- a program that prints received OSC packets\r\n"
"examples/SimpleSend -- a minimal program to send an OSC message\r\n"
"examples/SimpleReceive -- a minimal program to receive an OSC message\r\n"
"\r\n"
"osc/ contains all of the OSC related classes\r\n"
"ip/ contains the networking classes\r\n"
"\r\n"
"ip/windows contains the Windows implementation of the networking classes\r\n"
"ip/posix contains the POSIX implementation of the networking classes\r\n"
"\r\n"
"\r\n"
"Building\r\n"
"--------\r\n"
"\r\n"
"The idea is that you will embed this source code in your projects as you \r\n"
"see fit. The Makefile has an install rule for building a shared library and \r\n"
"installing headers in usr/local. It can also build a static library.\r\n"
"There is a CMakeLists.txt for building with cmake.\r\n"
"\r\n"
"Makefile builds\r\n"
"...............\r\n"
"\r\n"
"The Makefile works for Linux and Max OS X. It should also work on other platforms\r\n"
"that have make. Just run:\r\n"
"\r\n"
"$ make\r\n"
"\r\n"
"You can run \"make install\" if you like.\r\n"
"\r\n"
"\r\n"
"Cmake builds\r\n"
"............\r\n"
"\r\n"
"There is a CMakeLists.txt file which has been tested with cmake on \r\n"
"Windows and Linux. It should work on other platforms too.\r\n"
"For example, to generate a Visual Studio 10 project, run cmake \r\n"
"like this:\r\n"
"\r\n"
"> cmake -G \"Visual Studio 10\"\r\n"
"\r\n"
"Run cmake without any parameters to get a list of available generators.\r\n"
"\r\n"
"\r\n"
"Mingw build batch file\r\n"
"......................\r\n"
"\r\n"
"For Windows there is a batch file for doing a simple test build with \r\n"
"MinGW gcc called make.MinGW32.bat. This will build the test executables \r\n"
"and oscdump in ./bin and run the unit tests.\r\n"
"\r\n"
"\r\n"
"Note:\r\n"
"\r\n"
"In some rare instances you may need to edit the Makefile or \r\n"
"osc/OscHostEndianness.h to configure oscpack for the endianness of your \r\n"
"processor (see the comments at the top of the Makefile for details).\r\n"
"\r\n"
"\r\n"
"\r\n"
"Verification test\r\n"
"-----------------\r\n"
"\r\n"
"To run the unit tests:\r\n"
"\r\n"
"$ ./bin/OscUnitTests\r\n"
"\r\n"
"To run the send and receive tests. Open two terminals. In one run:\r\n"
"\r\n"
"$ ./bin/OscReceiveTest\r\n"
"\r\n"
"Then in the other terminal run:\r\n"
"\r\n"
"$./bin/OscSendTests\r\n"
"\r\n"
"\r\n"
"You should see an indication that the messages were received \r\n"
"in the first terminal.\r\n"
"\r\n"
"Note that OscSendTests intentionally sends some unexpected\r\n"
"message parameters to test exception handling in the receiver.\r\n"
"You will see some \"error while parsing message\" messages printed. \r\n"
"\r\n"
"You can use ./bin/OscDump to print out OSC messages received\r\n"
"from any program, including the test programs.\r\n"
"\r\n"
"\r\n"
"--\r\n"
"\r\n"
"\r\n"
"If you fix anything or write a set of TCP send/receive classes \r\n"
"please consider sending me a patch. My email address is \r\n"
"rossb@audiomulch.com. Thanks :)\r\n"
"\r\n"
"For more information about Open Sound Control, see:\r\n"
"http://opensoundcontrol.org/\r\n"
"\r\n"
"Thanks to Till Bovermann for helping with POSIX networking code and\r\n"
"Mac compatibility, and to Martin Kaltenbrunner and the rest of the\r\n"
"reacTable team for giving me a reason to finish this library. Thanks\r\n"
"to Merlijn Blaauw for reviewing the interfaces. Thanks to Xavier Oliver\r\n"
"for additional help with Linux builds and POSIX implementation details.\r\n"
"\r\n"
"Portions developed at the Music Technology Group, Audiovisual Institute, \r\n"
"University Pompeu Fabra, Barcelona, during my stay as a visiting\r\n"
"researcher, November 2004 - September 2005.\r\n"
"\r\n"
"Thanks to Syneme at the University of Calgary for providing financial \r\n"
"support for the 1.1.0 update, December 2012 - March 2013.\r\n"
"\r\n"
"See the file CHANGES for information about recent updates.\r\n"
"\r\n"
"See the file LICENSE for information about distributing and using this code.\r\n"
"\r\n"
"###\r\n";

const char* README2 = (const char*) temp_binary_data_18;

//================== TODO ==================
static const unsigned char temp_binary_data_19[] =
"TODO:\r\n"
"\r\n"
"    - consider adding the local endpoint name to PacketListener::PacketReceived() params\r\n"
"\r\n"
"    - consider adding ListenerThread class to support old seperate thread listener functionality, something like:\r\n"
"\r\n"
"        class UdpSocketListenerThread{\r\n"
"        public:\r\n"
"            UdpSocketListenerThread( UdpSocket& socket, Listener *listener );\r\n"
"            UdpSocketListenerThread( UdpSocketReceiveMultiplexer *mux );\r\n"
"            ~UdpSocketListenerThread();\r\n"
"\r\n"
"            void Run();\r\n"
"            void Stop();\r\n"
"        };\r\n"
"\r\n"
"    - work out a way to make the parsing classes totally safe. at a minimum this\r\n"
"    means adding functions to test for invalid float/doublevalues,\r\n"
"    making sure the iterators never pass the end of the message, ...\r\n"
"        (passing end of message can happen if:\r\n"
"            - too many args in type tags\r\n"
"                a. typetags overflow message size\r\n"
"                b. args fulfilling typetags overflow message size\r\n"
"            - strings too long or not terminated correctly\r\n"
"            - blobs too long or not terminated correctly\r\n"
"\r\n"
"        if the message was fully checked during construction, the end() iterator\r\n"
"        could be moved back until only arguments which fit withing size() may\r\n"
"        be interated (this could be none). A flag could be set to indicate that\r\n"
"        something was wrong.\r\n"
"\r\n"
"    - other packet badness could include:\r\n"
"        - time tags too far into the future (the scheduler should deal with\r\n"
"            that i guess).\r\n"
"        - message address patterns which aren't correctly terminated\r\n"
"\r\n"
"    - improve the ability to parse messages without tags (SC uses methods which\r\n"
"            get the data and advance the iterator in one step.)\r\n"
"        - Check* could be modified to do this - ie if typetags are not present\r\n"
"            it could check that reading the field won't escape the message size\r\n"
"            and return the data, or return false if some consistency\r\n"
"            constraint is violated.\r\n"
"        (or alternately drop support for messages without type tags)\r\n"
"        \r\n"
"\r\n"
"    - add a method to discard an inprogress message if it gets half\r\n"
"        constructed and the buffer is full in OutboundPacket\r\n"
"\r\n"
"    - write a stress testing app which can send garbage packets to try to flush out other bugs in the parsing code.\r\n"
"\r\n"
"\r\n"
"\r\n";

const char* TODO = (const char*) temp_binary_data_19;


const char* getNamedResource (const char*, int&) throw();
const char* getNamedResource (const char* resourceNameUTF8, int& numBytes) throw()
{
    unsigned int hash = 0;
    if (resourceNameUTF8 != 0)
        while (*resourceNameUTF8 != 0)
            hash = 31 * hash + (unsigned int) *resourceNameUTF8++;

    switch (hash)
    {
        case 0xfcd5c174:  numBytes = 5070; return CHANGELOG;
        case 0x63a1442d:  numBytes = 1475; return COPYING;
        case 0x064cb88a:  numBytes = 1437; return Makefile;
        case 0x8fd84dae:  numBytes = 5627; return README;
        case 0x2aaba65e:  numBytes = 2419; return README_simd;
        case 0xd58ec243:  numBytes = 2187; return compfft_py;
        case 0xd9b65b95:  numBytes = 2614; return fastfir_py;
        case 0xb3e1da74:  numBytes = 4794; return fft_py;
        case 0xc34a58e8:  numBytes = 2692; return Makefile2;
        case 0x33a64335:  numBytes = 3009; return mk_test_py;
        case 0x5b52b8d8:  numBytes = 3575; return testkiss_py;
        case 0x00274b38:  numBytes = 2126; return TIPS;
        case 0xc34a58e9:  numBytes = 1678; return Makefile3;
        case 0x56d6eea3:  numBytes = 7360; return CHANGES;
        case 0x90e15cf5:  numBytes = 1982; return CMakeLists_txt;
        case 0x34bc1021:  numBytes = 1661; return LICENSE;
        case 0x4786ca86:  numBytes = 1343; return make_MinGW32_bat;
        case 0xc34a58ea:  numBytes = 5029; return Makefile4;
        case 0x6b316844:  numBytes = 5381; return README2;
        case 0x00276046:  numBytes = 2330; return TODO;
        default: break;
    }

    numBytes = 0;
    return 0;
}

const int namedResourceListSize = 20;

const char* namedResourceList[] =
{
    "CHANGELOG",
    "COPYING",
    "Makefile",
    "README",
    "README_simd",
    "compfft_py",
    "fastfir_py",
    "fft_py",
    "Makefile2",
    "mk_test_py",
    "testkiss_py",
    "TIPS",
    "Makefile3",
    "CHANGES",
    "CMakeLists_txt",
    "LICENSE",
    "make_MinGW32_bat",
    "Makefile4",
    "README2",
    "TODO"
};

}
